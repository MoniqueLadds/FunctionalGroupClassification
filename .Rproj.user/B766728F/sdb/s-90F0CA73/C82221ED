{
    "collab_server" : "",
    "contents" : "plotEvals <- function(dat, measure){\n  ggplot(dat, \n         aes(x = cluster, y = value, color = distance))+\n    geom_point()+geom_line()+\n    theme_base()+\n    ylab(measure)+\n    xlab(\"Clusters\")+\n    scale_x_discrete(limits = c(2:9))+\n    #scale_y_continuous(limits = c(lowylim,highylim))+\n    scale_color_manual(values = group.colours)+\n    theme(panel.grid.minor.x\t= element_line(color = \"grey\"),\n          panel.grid.major.x\t= element_line(color = \"grey\"),\n          panel.grid.major.y\t= element_line(color = \"grey\"),\n          legend.title = element_blank())\n}\n\n\ntrend.plot <- function(num){\n  group <- as.character(clusters[clusters$X==num,4])\n  group <- paste(group,\".catch\",sep=\"\")\n  \n  num.group <- select(effort, one_of(group))\n  num.group$year <- as.numeric(effort$date)\n  summed.num <- num.group %>% group_by(year) %>% summarise_each(funs(sum))\n  \n  num.group <- melt(summed.num,id.vars = \"year\")\n  \n  ggplot(num.group, aes(x = year, y = value, col = variable))+\n    geom_line()+\n    theme_classic()\n}\n\n\n\n\nggproportions <- function(var, xaxis, title){\n  ggplot(melted[melted$variable==var,], aes(x=groups, y=count, fill = value))+\n  geom_bar(position = \"fill\", stat = \"identity\")+\n  ylab(\"Proportions\")+\n  xlab(\"\")+\n  scale_fill_manual(values=cbPalette)+\n  labs(fill = \"\")+\n  ggtitle(title)+\n  guides(fill = guide_legend(nrow = 1))+\n  theme(legend.position = \"top\",\n        axis.text.x = xaxis,\n        legend.key.height=unit(0, \"cm\"),      \n        legend.margin=margin(t=0, r=0, b=0, l=0, unit=\"cm\"),\n        plot.margin = unit(c(0.5,0.5,0,0.5), \"lines\"))\n}\n\n\ncomPartRep <- function(x, A, B, C, D, E, G, H, I){\n  wardsA <- comPart(comparison[,x],comparison[,A])\n  wardsB <- comPart(comparison[,x],comparison[,B])\n  wardsC <- comPart(comparison[,x],comparison[,C])\n  wardsD <- comPart(comparison[,x],comparison[,D])\n  wardsE <- comPart(comparison[,x],comparison[,E])\n  wardsG <- comPart(comparison[,x],comparison[,G])\n  wardsH <- comPart(comparison[,x],comparison[,H])\n  wardsI <- comPart(comparison[,x],comparison[,I])\n  wards <- melt(rbind(wardsA, wardsB, wardsC, wardsD, \n                      wardsE, wardsG, wardsH, wardsI))\n}\n\n\n#Rand index\ncompRandInd <- function(n,Indexij){\n  m<- matrix(0,n,n)\n  \n  for ( i in 1:n)\n  {\n    for (j in i:n)\n    {\n      m[i,j] <- randIndex(Indexij[,i],Indexij[,j])\n    }\n  }\n  m <- t(m)\n  return(m)\n}\n\n#Sensitivity\ncompSenseInd <- function(n,Indexij){\n  m<-matrix(0,n,n)\n  \n  for ( i in 1:n)\n  {\n    for (j in i:n)\n    {\n      m[i,j] <- sensitivity(Indexij[,i],Indexij[,j])\n    }\n  }\n  m <- t(m)\n  return(m)\n}\n\n#Specificity\ncompSpecInd <- function(n,Indexij){\n  m<-  matrix(0,n,n)\n  \n  for ( i in 1:n)\n  {\n    for (j in i:n)\n    {\n      m[i,j] <- specificity(Indexij[,i],Indexij[,j])\n    }\n  }\n  m <- t(m)\n  return(m)\n}\n\n#Precision (positive predictive value)\ncompPPVInd <- function(n,Indexij){\n  m<-  matrix(0,n,n)\n  \n  for ( i in 1:n)\n  {\n    for (j in i:n)\n    {\n      m[i,j] <- posPredValue(Indexij[,i],Indexij[,j])\n    }\n  }\n  \n  m <- t(m)\n  return(m)\n}\n\n#Negative predictive value\ncompNPVInd <-function(n,Indexij){\n  m<-   matrix(0,n,n)\n  \n  for ( i in 1:n)\n  {\n    for (j in i:n)\n    {\n      m[i,j] <- negPredValue(Indexij[,i],Indexij[,j])\n    }\n  }\n  m <- t(m)\n  return(m)\n}\n\n\nfit_nomclust <- function(distanceMethod,clusterMethod, cmin, cmax)\n                        {nomclust(dataSET, measure = distanceMethod, \n                                           method = clusterMethod,\n                                          clu_low = cmin, clu_high = cmax)}\n\n\ngroupfits <- function(final_fit,distMeasure,clusterMethod){\n  dataSET$groups <- final_fit$mem\n  cor.matrix <- sapply(final_fit$mem, function(x) as.matrix(dist(x,method = \"manhattan\")))\n  \n  for(k in 1:8) {\n    m2 <- melt(matrix(cor.matrix[,k],nrow = nrow(dataSET)))[melt(upper.tri(matrix(cor.matrix[,k],nrow = nrow(dataSET))))$value,]\n    m2$value<-ifelse(m2$value==0,\"Match\",\"NoMatch\")\n    names(m2) <- c(\"c1\", \"c2\", paste0(distMeasure,\"-\",clusterMethod,\"_\",k+1))\n    m2$c1<-factor(m2$c1,labels = namesComm[1:nrow(dataSET)-1])\n    m2$c2<-factor(m2$c2,labels = namesComm[2:nrow(dataSET)])\n    comparison <- merge(comparison,m2,by=c(\"c1\",\"c2\"))\n  }\n  return(comparison)\n}\n\n\nerrorPlots <- function(dat,ylab, ylim1, ylim2, xlabel){\n  scaleFUN <- function(x) sprintf(\"%.2f\", x)\n  \n  ggplot(dat, aes(Method, value))+\n  geom_bar(aes(fill = type), stat = \"identity\", position = \"dodge\")+\n  theme_bw()+\n    ylab(ylab)+\n    xlab(\"\")+\n    scale_y_continuous(limits = c(ylim1,ylim2), labels = scaleFUN)+\n    scale_fill_brewer(palette=\"Dark2\")+\n  theme(panel.border = element_blank(),\n        axis.title.x = element_text(size=11,vjust=0),\n        axis.title.y = element_text(size=11,vjust=2),\n        axis.text.x = element_text(size=10,vjust=2, angle = 90),\n        axis.text.y = element_text(size=11, color=\"black\"),\n        panel.grid.major = element_blank(), \n        panel.grid.minor = element_blank(), \n        axis.line.x = element_line(colour = \"black\"),\n        axis.line.y = element_line(colour = \"black\"),\n        legend.key=element_blank(),\n        legend.position=\"none\")}\n\n\n\ndeleteANDreplace <- function(dat,dat2,prop){\n  #pick rows from which we'll delete a column\n  idx = sample(nrow(dat), prop*nrow(dat)*ncol(dat))\n  \n  #pick a column corresponding to each row to delete\n  col_no = sample(ncol(dat), length(idx), replace = TRUE)\n  \n  #group sets of rows for which the same column will be deleted\n  delDF = split(data.frame(idx, col_no), f = col_no)\n  \n  for (ii in seq_along(delDF)) \n    dat[delDF[[ii]]$idx, delDF[[ii]][1L, 'col_no']] = NA\n  \n  cluster.imp <- missForest(dat, variablewise = TRUE)\n  \n  dat <- cluster.imp$ximp\n  output<-NULL\n  for (ii in seq_along(idx)){ \n    x<-dat[idx[ii], col_no[ii]]\n    y<-dat2[idx[ii], col_no[ii]]\n    xy<-cbind(x,y)\n    output<-rbind(output,xy)\n  }\n  output<-data.frame(output)\n  output$diff<-output$x-output$y\n  return(sum(output$diff==0)/nrow(output))\n}\n\n\n\nggdendPlot <- function(dst, hca, k, clust, dat){\n  library(ggplot2)\n  library(ggdendro)     # for dendro_data(...)\n  dendr    <- dendro_data(hca, type=\"rectangle\") # convert for ggplot\n  clust.df <- data.frame(label=rownames(dat), cluster=factor(clust))\n  dendr[[\"labels\"]]   <- merge(dendr[[\"labels\"]],clust.df, by=\"label\")\n  rect <- aggregate(x~cluster,dendr$labels,range)\n  rect <- data.frame(rect$cluster,rect$x)\n  ymax <- mean(hca$height[length(hca$height)-((k-2):(k-1))])\n  \n  ggplot() + \n    geom_segment(data=dendr$segments, aes(x=x, y=y, xend=xend, yend=yend)) + \n    geom_text(data=dendr$labels, aes(x, y, label=label, hjust=0,  size=1)) +\n    geom_rect(data=rect, aes(xmin=X1-0, xmax=X2+0, ymin=0, ymax=ymax), \n              color=\"red\", fill=NA)+\n    ylab(\"Distance\")+\n    coord_flip() + scale_y_reverse(element_blank(),expand=c(0, 2)) + \n    scale_x_continuous(element_blank(),expand = c(0, 1))+\n    theme_bw()+\n    theme(panel.border = element_blank(),\n          axis.title.x = element_blank(),\n          axis.title.y = element_text(size=11,vjust=2),\n          axis.text.x = element_blank(),\n          axis.text.y = element_text(size=11, color=\"black\"),\n          axis.ticks = element_blank(),\n          axis.line=element_blank(),\n          panel.grid.major = element_blank(), \n          panel.grid.minor = element_blank(), \n          axis.line.x = element_line(colour = \"black\"),\n          axis.line.y = element_line(colour = \"black\"),\n          legend.key=element_blank(),\n          legend.position=\"none\")\n}\n\ncount_blanks <- function(x) sum(x == \"\")/length(fishes$group)\n\ncount_zeros <- function(x) sum(x == 0)\n\ncount_NAs <- function(x) sum(is.na(x))\n\nreplaceBlanks <- function(x){\n  x[x == \"\"] <- NA\n}\n\nscaled <- function(x){var<-(x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\nreturn(var)}\n\nnormalised <- function(x) log(x)/log(max(x, na.rm = TRUE))\n\n\n\ncmapply <- function(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, \n                    USE.NAMES = TRUE)\n{\n  l <- expand.grid(..., stringsAsFactors=FALSE)\n  r <- do.call(mapply, c(\n    list(FUN=FUN, MoreArgs = MoreArgs, SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES), \n    l\n  ))\n  if (is.matrix(r)) r <- t(r) \n  cbind(l, r)\n}\n\n\n\nsimilar <- function(gower_mat, dat)  dat[which(gower_mat == min(gower_mat[gower_mat != min(gower_mat)]), arr.ind = TRUE)[1,],]\ndissimilar <- function(gower_mat, dat) dat[which(gower_mat == max(gower_mat[gower_mat != max(gower_mat)]), arr.ind = TRUE)[1,],]\n\n#Calculate the sil width for plotting\n\nsil_width <- function(dist){\n  width <- c(NA)\n  \n  for(i in 2:50){\n    pam_fit <- pam(dist,\n                   diss = TRUE,\n                   k = i)\n    \n    width[i] <- pam_fit$silinfo$avg.width\n  }\n  return(width)\n  \n}\n\n\n###Plot the silohette widths\nplot_silWidth <- function(title, width){\n  \n  png(filename = paste0(\"documents/figures/\", title, \".png\"), \n      height = 400, width = 600)\n  plot(1:50, width, \n       xlab = \"Number of clusters\",\n       ylab = \"Silhouette width\",\n       ylim = c(0,1),\n       main = paste0(title, \" \",\n                     round(max(width, na.rm = TRUE),4)))\n  lines(1:50, width)   \n  \n  dev.off()\n}\n\nMode <- function(x) {\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\n#summarise the results of the clustering model\npam_results <- function(data, variables, final_fit){\n  \n  data %>%\n    dplyr::select(variables) %>%\n    mutate(cluster = final_fit$clustering) %>%\n    group_by(cluster) %>%\n    do(the_summary = summary(.))\n  \n}\n\nhclust_results <- function(dat, variables, clust){\ndat %>%\n  dplyr::select(variables) %>%\n  mutate(cluster = clust) %>%\n  group_by(cluster) %>%\n  do(the_summary = summary(.))\n}\n\n\nprintbold <-\n  function(x, which = NULL, each = c(\"column\", \"row\"), max = TRUE,\n           NA.string = \"\", type = c(\"latex\", \"html\"),\n           sanitize.text.function = force,\n           sanitize.rownames.function = NULL,\n           sanitize.colnames.function = NULL, ...)\n  {\n    stopifnot(inherits(x, \"xtable\"))\n    each <- match.arg(each)\n    type <- match.arg(type)\n    digits <- rep(digits(x), length = ncol(x)+1)\n    if (!is.null(which)) {\n      stopifnot(nrow(which) == nrow(x))\n      stopifnot(ncol(which) == ncol(x))\n      boldmatrix <- which\n    } else {\n      boldmatrix <- matrix(FALSE, ncol = ncol(x), nrow = nrow(x))\n      ## round values before calculating max/min to avoid trivial diffs\n      for (i in 1:ncol(x)) {\n        if (!is.numeric(x[,i])) next\n        x[,i] <- round(x[,i], digits = digits[i+1])\n      }\n      if (each == \"column\") {\n        max <- rep(max, length = ncol(x))\n        for (i in 1:ncol(x)) {\n          xi <- x[,i]\n          if (!is.numeric(xi)) next\n          if (is.na(max[i])) next\n          imax <- max(xi, na.rm = TRUE)\n          if (!max[i])\n            imax <- min(xi, na.rm = TRUE)\n          boldmatrix[xi == imax, i] <- TRUE\n        }\n      } else if (each == \"row\") {\n        max <- rep(max, length = nrow(x))\n        for (i in 1:nrow(x)) {\n          xi <- x[i,]\n          ok <- sapply(xi, is.numeric)\n          if (!any(ok)) next\n          if (is.na(max[i])) next\n          imax <- max(unlist(xi[ok]), na.rm = TRUE)\n          if (!max[i])\n            imax <- min(unlist(xi[ok]), na.rm = TRUE)\n          whichmax <- sapply(xi, identical, imax)\n          boldmatrix[i, whichmax] <- TRUE\n        }\n      }\n    }\n    ## need to convert to character\n    ## only support per-column formats, not cell formats\n    display <- rep(display(x), length = ncol(x)+1)\n    for (i in 1:ncol(x)) {\n      if (!is.numeric(x[,i])) next\n      ina <- is.na(x[,i])\n      x[,i] <- formatC(x[,i], digits = digits[i+1],\n                       format = display[i+1])\n      x[ina, i] <- NA.string\n      display(x)[i+1] <- \"s\"\n      ## embolden\n      yes <- boldmatrix[,i]\n      if (type == \"latex\") {\n        x[yes,i] <- paste(\"\\\\textbf{\", x[yes,i], \"}\", sep = \"\")\n      } else {\n        x[yes,i] <- paste(\"<strong>\", x[yes,i], \"</strong>\", sep = \"\")\n      }\n    }\n    print(x, ..., type = type, NA.string = NA.string,\n          sanitize.text.function = sanitize.text.function,\n          sanitize.rownames.function = sanitize.rownames.function,\n          sanitize.colnames.function = sanitize.colnames.function)\n  }",
    "created" : 1528920331230.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3623751305",
    "id" : "C82221ED",
    "lastKnownWriteTime" : 1528138265,
    "last_content_update" : 1528138265,
    "path" : "C:/Users/laddsmo/Victoria University of Wellington - STAFF/OneDrive - Victoria University of Wellington - STAFF/Papers_Projects/FunctionalGroupClassification/FunctionalGroupClassification/0. functions.R",
    "project_path" : "0. functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}